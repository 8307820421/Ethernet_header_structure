
## TCP state machine
```
                              +------+        
                       +------|closed|-------+
                       |      +------+       |
                 +-----v-----+         +-----v-----+
                 |   listen  |         | send syn  |
                 +-----|-----+         +-----|-----+
                       +<-------[SYN]<-------+
                 +-----v-----+         +-----v-----+
                 |send synack|         | syn sent  |
                 +-----|-----+         +-----|-----+
                       +----->[SYN ACK]----->+    
                 +-----v-----+         +-----v-----+
                 |synack sent|         | send ack  |
                 +-----|-----+         +-----|-----+
                       +<-------[ACK]<-------+
                       |               +-----v------+
                       |               |con ack sent|
                       |               +-----|------+
                       +----------+----------+
                                  |
                              +---+---+
                              |compute| 
                              |win_scl|
                              +---|---+
                                  |
                              +---v---+
                              | init  | 
                              +---|---+   
                                  |
                          +-------v-------+    
                          |  established  |     
                          +---------------+        


```
# TCP logic architecture
The TCP logic apart described by it's top level module `tcp_vlg` consists of three modules:
- TCP packet parser `tcp_vlg_rx`,
- TCP packet assembler `tcp_vlg_tx`,
- TCP core `tcp_vlg_core`;
The `tcp_vlg_core` is further split into three modules:
- TCP receive control `tcp_rx_ctl`,
- TCP transmit control `tcp_tx_ctl`,
- TCP engine `tcp_vlg_engine`;
Interfaces are defined in `tcp_vlg_if.sv`.
## TCP receive control
TCP receive control keeps track of incomming packets by updating acknowledgement number. When receving a packet, `tcp_rx_ctl` will update acknowledgement number if all previous data was received, and will output received data. This sequence number is then passed to `tcp_vlg_engine` and updated to `TCB`. The sequence number is initialized by `tcp_vlg_engine` during connection establishment. All interaction between `tcp_vlg_engine` and `tcp_rx_ctl` is performed within `rx_ctl` instance of `buf_ctl` interface with modport containing receive-specific control signals.
TCP transmit control is the transmission queue of the TCP connection. `tcp_tx_ctl` aquires data directly from user logic, and stores, transmits or retransmits it. `tcp_tx_ctl` contains two types of RAM: packet information (i.e.: packet's sequence number, )
## TCP transmit control
- `tcp_vlg_tx_ctl` is the transmission control block. It holds TCP transmission buffer data and handles retransmission events, 
## TCP engine
TCP engine contains the main TCP state machine. `tcp_vlg_engine` is responsible for main TCP logic: connection establishment, termination and events. Events are generated in `tcp_vlg_evt` by using timers and keeping track of incoming packets.
User has control over TCP via `tcp_ctl` interface direcrly wired to `tcp_vlg_engine` and may set local and remote port (in case of active connection), start listening (passive or server mode) or try to establish a connection (active or clinet mode) to a specified IP, abort connection and monitor connection status.
epending on whether the server was listening (waiting for SYN packet) or connecting actively by sending SYN packet to a specified ip:port pair, connection will be performed differently as a server or client. The signals to control TCP are presented in `tcp_ctl` interface.
Either way, while performing the TCP three-way-handshake THS, a Transmission Control Block structure `tcb` is generated by `tcp_vlg_engine`, sequence number is initialized in `tcp_tx_ctl` and acknowledgement number in `tcp_rx_ctl` by `tcp_vlg_engine`. When preforming the THS, TCB is filled with ports, IP and MAC addresses for future reference, sequence number is generated by a pseudo-random number generator and acknowledgement number is derived from remote seq. After the main FSM results in established state, local Seq and Ack numbers begin to update from `tcp_tx_ctl` and `tcp_rx_ctl` respectively. 
Data is transferred with a seperate `tcp_data` interface. 
### Transmission Control Block
Transmission Control Block `tcb` is a struct of type `tcb_t` described in `tcp_vlg_pkg`. It contatins infrormation on current connection:
- Local TCP port,
- Remote TCP port and IP address,
- Local Ack and Seq numbers,
- Last updated remote Ack and Seq numbers,
- Whether remote MAC is known (to skip ARP);

## RX control
Receive control is a module inside the TCP core that keeps track of local acknowledgement, and passing received data to usre logic. 
### Acknowledgment control
Acknowledgement control instantiated in `rx_ctl` is responsible for reporting successfully received data to remote host by generating pure acks (those with zero payload). The logic supports delayed acknowldegment and skips pure acks if actual ack number was already reported together with payload. The logic 
### TCP events
- `tcp_vlg_evt` is responsible for generating TCP events, such as ack timeout, acking after receiving two segments and keepalive acks

These three modules compose the `tcp_engine` logic. `tcp_engine` is connected to `tcp_vlg_rx` and `tcp_vlg_tx`.

             +---engine----------------------------------------+                              
             |                                 
             |                 +---------+  +--evt-------+     |
             |                 |      |  | ack        |    
             |                 |         |  | keep-alive |    
             |                 |         |  | disconnect |    
             |                 |         |  +------------+    
             |                 |         |                    
            <------------------|         |----------------->       
             |                 |         |                    
  +---rx---+ |                 |         |         +-tx_ctl-+   
  |        |                   |init seq ---------->         |   
  |        |                   |         |         |         |   
  |        |                   |  FSM    <-buf_ctl>         |   
  |        |                   |         |         |         |  +---tx---+
  |        |                   |       + -----------         |  |        |  
  +--------+                   +-------|-+         +---------+  |        |  
                                       +------------------------>        |  
                                                                |        |  
                                                                |        |
                                                                +--------+

           |        |FSM |
           | =metaa=|    |
           |        |    |
           | +-----------+       |    |
           | |  tcp_fsm  |=metaa=|    |  
           | +-----^-----+       |    ==>
           |    buf|ctl         |    |  
           | +-----v-------+     |    |            
           | | tcp_tx_ctl |metaa|    |            
           | +-------------+     |    |            
           +-----------------------------+





### tcp_vlg

`tcp_vlg` contains all logic responsible for TCP operation. It consists of several modules:
- `tcp_vlg_rx` Receiver handler. Parses incoming packets
- `tcp_vlg_tx` Transmit handler. Composes packets to transmit
- `tcp_vlg_tx_buff` is responsible for retransmission logic and pld checksum calculation. It stores raw TCP data from user logic in 8-bit RAM. Information such as length, sequence number and checksum is stored for each packet in a seperate `pkt_info` RAM. Information stored also includes retransmission-specific information. When a new packet is pending for transmission, space in allocated in transmission buff data RAM and a corrseponding entry is created in info RAM with all necssary information. The latter RAM is constantly scanned through and logic keeps track of unacked packets and tries to retransmit them after time based on TCP_RETRANSMIT_TICKS. `tcp_vlg_tx_buff` also generates a cts signal. The cts logic allows user to stop data strm 1 tick after ctr goes low to avoid data loss (or wiring cts signal to user logic instead of using a trigger).
- `tcp_vlg_server` TCP core. The state machine here handles connection establishment, and termination. The user control interface is implemented here described in Table 2.  Depending on run-time signals `connect` and `listen`, server can connect by IPv4 or listen for incoming connection.
### Server logic

After reset, the FSM is in idle state. Asserting `listen` signal will transition to a state which listens to incoming connection, that is, a packet with SYN flag set targeting local TCP port. Asserting `connect` signal will generate a TCP packet targeting `rem_port` TCP port and `rem_ipv4` IPv4 address. After either signal is asserted, a structure called *Transmission Control Block* or *TCB* is filled with information about connection being created.
After successfully performing the three-way handshake, the FSM results is in *connected* state in which data transfer takes place.
TCB rem_ack and rem_seq are being updated with TCP packets received and loc_ack and loc_seq are being updated from internal logic.
### Transmission buff and retransmissions

TCP receiver does not need to acknowledge each packet, instead it may cknowledge multiple packets if all were received successfully. This implies that sender stores all unacknowledged data and may retransmit unacknowledged packets.
Transmission buff stores user data in an 8-bit RAM which is filled with new user data and freed as remote acknowledge progresses. A seperate `pkt_info` RAM is also filled with information about each packet when it is formed: sequence number, length and checksum as well as retransmission timer and retransmissions count. After being formed, the packets may only be transmitted as written without the ability to split and/or combine them. This limitation is imposed to avoid recalculating TCP pld checksum. There are several conditions in which the packet is considered complete and is buffd for transmission:
- Data RAM full;
- MSS reached;
- No new data for TCP_TX_TIMEOUT ticks (default: 50);
- Packet forced to be buffd without waiting for TCP_TX_TIMEOUT by asserting `tcp_snd`.

buff's FSM continiously scans `pkt_info` RAM for entries with `present` flag set. This flag indicates that a packet is still stored in data RAM because it is not acked by the receiver yet. After finding and entry with `present` flag set, the buff FSM processes the packet in one of the following ways:
- Packet's *sequence* number plus packet's *length* is **less or equal** than remote *acknowledgment* number indicates that packet is acked. Present flag will be cleared releasing space for next packets in data RAM and `pkt_info` RAM.
- Packet's *sequence* number plus packet's length **higher** than remote *acknowledgment* number and retransmit timer less than timeout value indicates that packet is yet unacknowledged, but there is still time for remote device to acknowledge it before retransmission occurs. Retransmit timer is incremented and next packet is processed.
- Packet's *sequence* number plus packet's *length* **higher** than remote *acknowledgment* number and *retransmit timer* **equal** to *timeout* value indicates that packet is unacknowledged and retransmission timeout is reached. Retransmission occurs, number of *retransmission tries* is incremented and *retransmit timer* is reset to zero. Note that when a new entry is created, retransmit timer is preloaded with timeout value, so the first time a new packet is transmitted without waiting for retransmission timeout.
- Packet's *retransmission tries* reaching retransmission limit will trigger forced connection termination.

Transmission buff is directly wired to user transmission logic with `tcp_din`, `tcp_vin`, `tcp_cts` and `tcp_snd`.
